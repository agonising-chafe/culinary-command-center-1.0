# Culinary Command Center – System Blueprint

This document explains how the app is structured, how data flows through it, and how to run, develop, and deploy it. Share it with collaborators for a quick, accurate understanding of the codebase.

## Stack & Key Libraries

- Next.js App Router (React, TypeScript)
- Tailwind CSS (via `@tailwindcss/postcss`)
- Zustand store for app state
- Supabase (Postgres + storage) via `@supabase/supabase-js`
- PWA via `next-pwa` (service worker + precache)

## App Overview

- UI surfaces a weekly planner grid and recipe cards with modal details and actions (print/share/export).
- Data loads from Supabase recipes table when configured; otherwise falls back to bundled mock data.
- Full CRUD is exposed through a single Next.js API route; the frontend store talks to this API.
- As a PWA, the app precaches assets in production and includes update UX to avoid stale builds.

## File Map (Entry Points)

- App shell: `app/layout.tsx:1` (global CSS, PWA helpers, top-level HTML/body)
- Home page: `app/page.tsx:1` (renders planner and recipes)
- API routes:
  - `app/api/recipes/route.ts:1` – unified CRUD (GET/POST/PUT/DELETE)
  - `app/api/test-db/route.ts:1` – connectivity probe to Supabase
- Store: `lib/useRecipeStore.ts:1` – fetches via API; provides `initialize`, `refresh`, `saveRecipe`, `deleteRecipe`
- Supabase client (server-side contexts only): `lib/supabaseClient.ts:1`
- Mock data: `lib/mockRecipes.ts:1`
- Types: `types/recipe.d.ts:1`
- UI components (selected):
  - `components/PlannerGrid.tsx:1`, `components/RecipeCard.tsx:1`, `components/RecipeModal.tsx:1`
  - `components/Navbar.tsx:1`, `components/ExportMenu.tsx:1`
  - PWA UX: `components/DevSwUnregister.tsx:1`, `components/SWUpdatePrompt.tsx:1`, `components/UpdateButton.tsx:1`, `components/RefreshToast.tsx:1`

## Data Model (Recipes)

Assumed DB table `recipes` (schema configurable; defaults to `public`):

- id (uuid) – primary key
- name (text)
- image_url (text) – optional; UI also accepts `image` and normalizes
- time (int, default 0)
- calories (int, default 0)
- ingredients (jsonb, default `[]`)
- instructions (jsonb or text/jsonb, default `[]`)

Recommended normalization (run in Supabase SQL editor):

```
ALTER TABLE public.recipes
  ALTER COLUMN time DROP NOT NULL,
  ALTER COLUMN time SET DEFAULT 0,
  ALTER COLUMN calories DROP NOT NULL,
  ALTER COLUMN calories SET DEFAULT 0;

ALTER TABLE public.recipes
  ALTER COLUMN ingredients DROP DEFAULT,
  ALTER COLUMN instructions DROP DEFAULT;

ALTER TABLE public.recipes
  ALTER COLUMN ingredients TYPE jsonb USING to_jsonb(ingredients),
  ALTER COLUMN instructions TYPE jsonb USING to_jsonb(instructions);

ALTER TABLE public.recipes
  ALTER COLUMN ingredients SET DEFAULT '[]'::jsonb,
  ALTER COLUMN instructions SET DEFAULT '[]'::jsonb;
```

## Environment Variables

Create `.env.local` with:

- `NEXT_PUBLIC_SUPABASE_URL=https://<project>.supabase.co`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY=<anon-key>`
- `NEXT_PUBLIC_SUPABASE_SCHEMA=public` (optional)
- `NEXT_PUBLIC_SUPABASE_IMAGE_COLUMN=image_url` (optional; set to `image` if your column is named `image`)

## Data Flow

1) UI mounts and the store initializes.
   - Store calls `GET /api/recipes`.
   - On success, maps API rows to `Recipe` and sets `source: "db"`.
   - On failure, falls back to `mockRecipes` with `source: "mock"`.

2) Mutations (create/update/delete) use the API route.
   - `saveRecipe` sends POST if no `id`, else PUT.
   - `deleteRecipe` sends DELETE with `?id`.
   - On success, store updates its in-memory list optimistically.

3) API layer talks to Supabase.
   - Respects `schema` and `image`/`image_url` column via env.
   - Sanitizes inputs with defaults to avoid constraint errors.

## API Contract

- Base: `/api/recipes`

- GET `/api/recipes`
  - Response: `{ ok: true, data: RecipeRow[] }`

- POST `/api/recipes`
  - Body: `{ name, image_url?, time?, calories?, ingredients?, instructions? }`
  - Response: `{ ok: true, data: RecipeRow }`

- PUT `/api/recipes`
  - Body: `{ id, ...fieldsToUpdate }`
  - Response: `{ ok: true, data: RecipeRow }`

- DELETE `/api/recipes?id=<uuid>`
  - Response: `{ ok: true, message }`

See implementation: `app/api/recipes/route.ts:1`.

## Store API (Frontend)

Located in `lib/useRecipeStore.ts:1` and provides:

- `initialize(): Promise<void>` – initial load via API (fallback to mock)
- `refresh(): Promise<void>` – refetch via API and remap
- `saveRecipe(recipe: Partial<Recipe>): Promise<void>` – POST/PUT with local merge
- `deleteRecipe(id: string): Promise<void>` – DELETE and local removal

`Recipe` type: `types/recipe.d.ts:1`.

## PWA Behavior & Update UX

- PWA enabled in production builds (`next build` + `next start`), disabled in dev.
- Service worker generated by `next-pwa` (see `next.config.js:1`).
- Dev safety:
  - `components/DevSwUnregister.tsx:1` unregisters SWs and clears caches in development to prevent stale chunk 404s.
- Production update UX:
  - `components/SWUpdatePrompt.tsx:1` prompts users to refresh when a new SW is ready.
  - `components/UpdateButton.tsx:1` in the Navbar provides a manual “Refresh” that clears caches and forces SW activation.
  - Post-reload toast: `components/RefreshToast.tsx:1` confirms a successful update.

## Theming & Styles

- Tailwind config: `tailwind.config.js:1`
- PostCSS: `postcss.config.js:1`
- Global styles: `app/globals.css:1`

## Local Development

1) Install: `npm install`
2) Dev server: `npm run dev` → http://localhost:3000
3) Production test: `npm run build && npm run start`
4) PWA checks: Chrome DevTools → Application → Service Workers

If you see chunk 404s in dev, hard refresh or click the Navbar’s Refresh button (which unregisters/clears in dev via the helper component).

## Deployment Notes

- The service worker is generated at build; avoid committing SW artifacts.
- `.gitignore` includes generated `public/sw.js` and `workbox-*.js`.
- Verify env vars in the deploy environment (Vercel/Netlify, etc.).

## Troubleshooting

- 23502 NOT NULL (time/calories): ensure defaults are set to `0` or provide values in inserts.
- 42804 type cast on JSONB: run the migration block above to convert and set defaults.
- Stale UI after deploy: use Refresh button or wait for SW update prompt; ensure `skipWaiting/clientsClaim` are active (default in `next-pwa`).

---

For deeper dives, start with these files in your editor:

- API route: `app/api/recipes/route.ts:1`
- Store: `lib/useRecipeStore.ts:1`
- Home page: `app/page.tsx:1`
- Navbar: `components/Navbar.tsx:1`
- Modal: `components/RecipeModal.tsx:1`

## Health Endpoint

- File: `app/api/health/route.ts:1`
- GET `/api/health`
  - Returns `{ ok: boolean, env: { supabase_url_set, supabase_key_set, schema }, supabase: { reachable, query_ok, error? }, table?: { name, exists } }`
  - Always returns HTTP 200 (even when env is missing) to simplify checks.
